

# ~ # ~ #       FIND THE TEXT OF THE QUESTION s      # ~ # ~ #
# ~ # ~ #              AT THE LINK BELOW:            # ~ # ~ #

# http://www.geeksforgeeks.org/top-10-algorithms-in-interview-questions/#algo4 #

# ~ # ~ #             TODO: run the specs by         # ~ # ~ #
# ~ # ~ #         running the folling command        # ~ # ~ #
# ~ # ~ #           from the root directory:         # ~ # ~ #

# ~ # ~ #            ruby lib/test_cases.rb          # ~ # ~ #


## NB: No specs yet for p9 ans p10

# ____________________________________________________________________
# Problem 0: Pre-order / Post-Order Traversals
# ____________________________________________________________________

class BinarySearchTree

  def pre_order_traversal(tree_node = @root, arr = [])
    # your code here
  end


  def post_order_traversal(tree_node = @root, arr = [])
    # your code here
  end

end

# ____________________________________________________________________
# Problem 1: Minimum / Maximum Depth
# ____________________________________________________________________

      # # NB: if you want to count your root node as 0 depth,
      # # change the method, zero_indexed_depth?, to true
      # # and it will flow through the test cases

def zero_indexed_depth?
  false
end

def minimum_depth(tree_node)

end

def maximum_depth(tree_node)

end
# ____________________________________________________________________
# Problem 2: Maximum Path Sum
# ____________________________________________________________________

def max_path_sum(bt)

end



# ____________________________________________________________________
# Problem 3: Array is Possible Pre-order
# ____________________________________________________________________

def possible_pre_order?(array)

end
# ____________________________________________________________________
# Problem 4: Full or Nah?
# ____________________________________________________________________

def full_tree?(tree_node)

end

# ____________________________________________________________________
# Problem 5: Bottom View Binary Tree
# ____________________________________________________________________

def bottom_view(root)

end


# ____________________________________________________________________
# Problem 6: Print Nodes in Top View of Binary Tree
# ____________________________________________________________________

def top_view(root)

end

# ____________________________________________________________________
# Problem 7: Remove paths less than length k
# ____________________________________________________________________


def limit_path_length(binary_tree, k)

end

# ____________________________________________________________________
# Problem 8: Lowest Common Ancestor
# ____________________________________________________________________

    # In a binary search tree, an *ancestor* of a `example_node` is a node
    # that is on a higher level than `example_node`, and can be traced directly
    # back to `example_node` without going up any levels. (I.e., this is
    # intuitively what you think an ancestor should be.) Every node in a binary
    # tree shares at least one ancestor -- the root. In this exercise, write a
    # function that takes in a BST and two nodes, and returns the node that is the
    # lowest common ancestor of the given nodes. Assume no duplicate values.

def lca(bst, node1, node2)

end


# ____________________________________________________________________
# Problem 9: Subtree of another BST?
# NO TESTS YET
# ____________________________________________________________________

def valid_subtree?(root1, root2)

end

# ____________________________________________________________________
# Problem 10: Reverse Alternate Levels of a perfect BST
# NO TESTS YET
# ____________________________________________________________________
